<!DOCTYPE html>
<html lang="en">
<head>
	<title>JS FE</title> 
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
</head>
<body>


	
	<script>
		// 'use strict'

		// x= null;// x is not defined
	// objects deeper

	// ?

	const user = {
		name: 'John',
		age: 33,
		// address: {
		// 	street: 'North Ave',
		// 	city: 'NY'
		// }
	}

	// undefined if address exists but no street
	// Cannot read properties of undefined (reading 'street') if empty object or no address
	console.log(user?.address?.street);  // returns undefined if no address and no exception


	// console.log(o?.address?.zip); // ReferenceError: o is not defined

	let a = null;

	a?.sayHello();



	// this 

	let admin = {
		firstname: 'Jane',
		lastname: 'Doe',
		sayHello(){
			console.log(`Hello! My name is ${admin.firstname}`);
		}
	}

	admin.sayHello();

	let siteOwner = admin;
	siteOwner.sayHello();

	admin = null;

	// siteOwner.sayHello(); // Uncaught TypeError: Cannot read properties of null (reading 'name')


	let b = {
		firstname: 'Ann',
		lastname: 'Doe',
		greet(){
			console.log(`Hi! I am ${this.firstname}`);
		}
	}

	b.greet();

	let c = b;
	b = null;
	c.greet();

	// this - context - is always object before point -> c.greet() 'this' is 'c'


	function sayName(){
		console.log(`Hi! I am ${this.firstname} ${this.lastname}`);
	}

	sayName();

	c.sayName = sayName; // we save in property sayName function with same name
	c.sayName();

	siteOwner.n = sayName;
	siteOwner.n();


	let family = {
		lastname : 'Johnsons',
		son: {
			name: 'John junior',
			age: 11
		},
		mom: {
			name: 'Jennyfer',
			age: 33,
		},
		dad: {
			name: 'John',
			age: 44
		}
	}

	function showAge(){
		 console.log(`${this.name} is ${this.age} years old`);
		}

	family.dad.a = showAge;
	family.mom.a = showAge;
	family.son.a = showAge;

	family.mom.a();
	family.son.a();


	//  if none, this is undefined
	// sayName(); // no error in code, just undefined in non-strict mode
	// Cannot read properties of undefined (reading 'firstname') if in use strict mode


	// flags and descriptors

	// writable enumerable configurable

	console.log(Object.getOwnPropertyDescriptors(c));
	console.log(Object.getOwnPropertyDescriptor(c, 'firstname'));

	Object.defineProperty(c, 'firstname', {
		enumerable: false,
		writable: false, 
		configurable: false
	});

	c.firstname = 'Mary'; // in strict mode TypeError: Cannot read properties of undefined (reading 'firstname')
	console.log(c.firstname);

	for(let prop in c){
		console.log(prop);
	}

	// Object.defineProperty(c, 'firstname', {
	// 	enumerable: true
	// }); // TypeError: Cannot redefine property: firstname
	console.log(Object.getOwnPropertyDescriptors(c));



	let y = {
		a: 4,
		b: 5,
	}

	Object.defineProperties(y, {
		a: {enumerable: false},
		b: {enumerable: false}
	});

	for(let prop in y){
		console.log(prop);
	}

	let r = {
		a: 1,
		b: 2
	}

	for(let prop in r){
		Object.defineProperty(r, prop, {
			writable: false
		});
	}

	console.log(Object.getOwnPropertyDescriptors(r));


	// global freeze

	let v = {
		name: 'Victoria',
		age: 33
	}

	Object.preventExtensions(v); // can not add new props or remove existing
	v.lastname = 'M';
	console.log(v);
	// delete v.name;


	Object.seal(v); // can not add new props + configurable:false 
	// Object.defineProperty(v, 'name', {configurable: true}); // Cannot define property name, object is not extensible
	console.log(Object.getOwnPropertyDescriptor(v, 'name'));

	Object.freeze(v);// can not add new props + configurable:false  + writable: false for all existing props

	console.log(Object.isExtensible(v)); // can we add/remove props
	console.log(Object.isSealed(v)); // can we add/remove props + redefine props
	console.log(Object.isFrozen(v)); // can we add/remove props + redefine props + rewrite props


	// accessors

	let student = {
		firstname: 'Jason',
		lastname: 'Johnson',
		get fullname(){
			return `${this.firstname} ${this.lastname}`;
		},
		set fullname(newname){
			[this.firstname, this.lastname] = newname;
		}
	}

	console.warn(student.fullname);
	// student.fullname = 'Mark Peterson'; // no result in standart mode, in strict mode TypeError: Cannot read properties of undefined (reading 'firstname')
	student.fullname = ['Mark', 'Peterson'];
	console.warn(student.fullname);



	// descriptors for accessors

	// get, set, enumerable, configurable [no value and writable]

	let teacher = {
		course: 'Javascript',
		_department: 'Front End'
	}


	Object.defineProperty(teacher, 'dept', {
		get(){
			return this._department;
		},
		set(val){
			// this._department = val;
			Object.defineProperty(teacher, '_department', {enumerable: false, writable: false, value: val});
		},
		configurable: false,
		// value: 111 //ypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute,
	});

	Object.defineProperty(teacher, '_department', {enumerable: false, writable: false});

	for(let prop in teacher){
		console.log(prop);
	}

	teacher._department = 'History';
	console.log(teacher._department);
	teacher.dept = 'History';
	console.log(teacher._department);


	// smart setters

	Object.defineProperty(student, 'fullname', {
		set(newname){
			if(typeof newname != 'object' || newname.length < 2){
				console.error('Incorrect name!');
			}
			else{
				for(let item of newname){
					if(item.length < 3 || typeof item != 'string'){
						console.error('Incorrect name length!');
					}
				}
				[this.firstname, this.lastname] = newname;
			}
		}
	});


	let customer = {
		name: 'Tom',
		age: 45
	}


	let customer2 = {
		name: 'Richard',
		birthday: new Date(1981, 6, 1)
	}

	function checkAge(){
		if(this.age != undefined){
			console.log(`this user is ${this.age} y.o.`);
		}
		else{
			let age = new Date().getFullYear() - this.birthday.getFullYear();
			console.log(`this user is ${age} y.o.`);
		}
	}

	Object.defineProperty(customer2, 'age', {
		get(){
			return new Date().getFullYear() - this.birthday.getFullYear();
		}
	});

	console.log(customer2.age);












	</script>
</body>
</html>